//"use strict";

var url = require('url');
var http = require('http');
var async = require('async');

var postcss = require('postcss');
var sizeOf = require('image-size');


module.exports = postcss.plugin('padding', function padding(options) {

	options = options || {};

	return function (css, result) {

	
		var oldParams = [];
		var urlArray = [];
		var newParams = [];

		css.walkRules(function(rule) {

			var paddingBottom;

			// Match the individual rule selector 
			if ( rule.nodes[0].name.indexOf('include') !== -1 ) { 

				var thisInclude = rule.nodes[0].params.split("(")[0];
			 	
				if (thisInclude === 'full-width' || thisInclude === 'image'){

					var params = rule.nodes[0].params;
					var imageUrl = params.split("\'")[1];
					var urlWithPreset = imageUrl + '?$retina$';

					oldParams.push(params);
					urlArray.push(urlWithPreset);

				}

			}
		});

		/*cycle through urls getting paddingbottoms*/

		for (var i = 0; i < urlArray.length; i++) {

			var options = url.parse(urlArray[i]);
			var oldParam = oldParams[i];

			http.get(options, function (response) {
				var chunks = [];
					response.on('data', function (chunk) {
					chunks.push(chunk);
				}).on('end', function() {
					var buffer = Buffer.concat(chunks);
					var dimensions = sizeOf(buffer);

					paddingBottom = (dimensions.height/2400) * 100;
					paddingBottom = paddingBottom.toFixed(3);
					paddingBottom = ', ' + paddingBottom + "% )";

					var newParam = (oldParam.substring(0, oldParam.length - 1)) + paddingBottom;

					newParams.push(newParam);

				});
			});
	
		}

		

		css.walkRules(function(rule) {

			var i = 0;
			// Match the individual rule selector 
			if ( rule.nodes[0].name.indexOf('include') !== -1 ) { 

				var thisInclude = rule.nodes[0].params.split("(")[0];
			 	
				if (thisInclude === 'full-width' || thisInclude === 'image'){

					i++;
					rule.nodes[0].params = newParams[i];
					
				}

			}

			console.log(rule);

		});



	}
});